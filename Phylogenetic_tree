# This script takes in a string "species" which is the name of an organism and a string "title" which is the name of the run (names of the files)
# It returns a fasta file with every complete genomic sequences of the input organism available in Genbank

# Arguments collection
# args <- commandArgs(trailingOnly = T)
# species <- args[1] #ex : LSDV, Sheeppox_virus
species <- "Capripoxvirus"
title <- "CPPV"



## Collecting the IDs of the sequences #

sp <- paste (species, "[organism] AND complete genome [title]")
#sp2 <- paste (species, "[organism] AND genomic sequence [title]")
# adjust for "genomic sequence"

## Query used to ask the database
query <- entrez_search(db="nuccore", term=sp ,retmax=99999)
#query2 <- entrez_search(db="nuccore", term=sp2 ,retmax=99999)
  # extracting the IDs of every sequence that matches the query
IDs <- c(query$ids)  #storing the IDs
str(IDs) 

## Collecting the sequences
sequences <- rentrez::entrez_fetch(db="nuccore", IDs, rettype="fasta")
# With the IDs, extracting the fasta sequences
titre = paste(title,"CPPV.fasta",sep = "_") #Name of the fasta file
str(sequences)
write(sequences, titre, sep="\n",append=F)
#one fasta file is created, with every single sequence

cat(IDs)
flush.console() #The variable IDs is stored in the next steps,
           # in the shell script (in a text file called IDs.txt)

## Accessing with restez the country and the collection date for each ID.
metadata <- sapply(IDs, function(ID){
  #First : get the information of the genbank file in text.
  suppressMessages(genbank_data <- entrez_fetch(db="nucleotide",
                                id=ID,rettype = "text", retmode="text"))
  
  #Extracting the "features" part
  features <- gb_extract(genbank_data, what = c("features"))
  
  host <-  features[[1]]$host
  
  #Extracting the collection date (4 possible ways):
    # if there is a "collection_date" feature :
    collection_date <- features[[1]]$collection_date
  
    #if there is a collected_by feature
    if (is.null(collection_date) && !is.null(features[[1]]$collected_by) ){
      collection_date <- features[[1]]$collected_by
    } # end if
    
    #if the date is in the "note" feature
    else if(is.null(collection_date)&& !is.null(features[[1]]$note)){
      if(length(features[[1]]$note[grepl("(19|20)[0-9]{2}",
                                         features[[1]]$note)])!=0){
      collection_date<-regmatches(features[[1]]$note[grepl("(19|20)[0-9]{2}",
      features[[1]]$note)],regexpr("(19|20)[0-9]{2}", features[[1]]$note))[1]}
    } # end else if
    
    #if the date is in the "isolate" feature
    else if(is.null(collection_date)&& !is.null(features[[1]]$isolate)){
      if(length(features[[1]]$isolate[grepl("(19|20)[0-9]{2}",
                                          features[[1]]$isolate)])!=0){
    collection_date<-regmatches(features[[1]]$isolate[grepl("(19|20)[0-9]{2}",
        features[[1]]$isolate)], regexpr("(19|20)[0-9]{2}", 
                                         features[[1]]$isolate))[1]
      } # end if
    } # end else if
  #Extraction of the country
  country <- features[[1]]$country
  
  print(paste ("Collecting the information for ", ID,  ", please wait"))
  print(country)
  print(collection_date)
  print(host)
  return(c(country,collection_date,host))
})

print("Information successfully collected")
View(metadata)
##Opening a new file to create new headers
new_fasta <- "transientfile.fasta"
old_fasta = paste(title,"CPPV.fasta",sep = "_")
file_conn <- file(old_fasta, "r") 
output_conn <- file(new_fasta, "w")

# Iterate the fasta line by line
i <- 1
while (length(line <- readLines(file_conn, n = 1)) > 0) {
  if (startsWith(line, ">")) {#At each sequence header
    modified_line <- paste(line, gsub("c\\(|\\)", "", metadata[i]), sep = "_")
    #Add the metadata information
    i <- i+1
  } else {
    modified_line <- line
  }
  writeLines(modified_line, output_conn)
}
close(file_conn)
close(output_conn)

##Now suppress the unnecessary information in the headlines
fasta <- readLines("transientfile.fasta")
fasta_modified <- gsub("complete genome|Capripoxvirus |Capripox_virus|CPPV|isolate|genomic sequence|_NULL| strain|\"|\'|:|,|\\)|\\(", "", fasta) #Removing non relevant information
fasta_modified2 <- gsub(" |  ", "_", fasta_modified)
#Getting rid of the spaces, for the tree labels later
fasta_modified2 <- gsub("strain", "", fasta_modified2) 
fasta_modified2 <- gsub(" ", "_", fasta_modified2) 
fasta_modified2 <- gsub("__", "_", fasta_modified2) 
fasta_modified2 <- gsub("__", "_", fasta_modified2) 
fasta_modified2 <- gsub("-", "_", fasta_modified2) 
fasta_modified2 <- gsub("/", "_", fasta_modified2)
fasta_modified2 <- gsub(";", "", fasta_modified2)
fasta_modified2 <- gsub(":", "", fasta_modified2)
fasta_modified2 <- gsub(",", "_", fasta_modified2)
fasta_modified2 <- gsub("'", "", fasta_modified2)
fasta_modified2 <- gsub("()", "", fasta_modified2)
writeLines(fasta_modified2, old_fasta)
str(fasta_modified2)
file.remove("transientfile.fasta") # 108 samples



####################################
#### Reverse Complement (RC) DNA ###
####################################

in1 <- seqinr::read.fasta(old_fasta, seqtype = c("DNA"), as.string = T)
typeof(in1[1])
str(in1)

reverse_complement <- function (dna) {
    bases = toupper(strsplit(dna, '')[[1L]])
    compl = ifelse(bases == 'A', 'T',
        ifelse(bases == 'C', 'G',
        ifelse(bases == 'G', 'C',
        ifelse(bases == 'T', 'A', 'N'))))
paste(rev(compl), collapse = '')}

# reverse_complement(c("ATGCCCCC"))

#############
## SPPV RC ##
#############

m1 <- microseq::reverseComplement(in1$KT438550.1_Sheeppox_virus_SPPV_GH_11_Apr_2013_Ovis_aries[[1]])
str(m1)
m2 <- microseq::reverseComplement(in1$KT438551.1_Sheeppox_virus_SPPV_GL_11_Apr_2013_Ovis_aries [[1]])
str(m2)

in1$KT438550.1_Sheeppox_virus_SPPV_GH_11_Apr_2013_Ovis_aries[[1]] <- m1
str(in1$KT438550.1_Sheeppox_virus_SPPV_GH_11_Apr_2013_Ovis_aries[[1]])

in1$KT438551.1_Sheeppox_virus_SPPV_GL_11_Apr_2013_Ovis_aries [[1]] <- m2
str(in1$KT438551.1_Sheeppox_virus_SPPV_GL_11_Apr_2013_Ovis_aries [[1]])


#############
## LSDV RC ##
#############

m3 <- microseq::reverseComplement(in1$OK422492.1_Lumpy_skin_disease_virus_LSDV_Cattle_India_2019_Ranchi_1_P10_31_Dec_2019_Bos_indicus [[1]])
str(m1)
m4 <- microseq::reverseComplement(in1$OK422493.1_Lumpy_skin_disease_virus_LSDV_Cattle_India_2019_Ranchi_1_P30_31_Dec_2019_Bos_indicus [[1]])
str(m2)
m5 <- microseq::reverseComplement(in1$ON400507.1_Lumpy_skin_disease_virus_208_PVNRTVU_2020_2020_cattle [[1]])
  str(m3)
m6 <- microseq::reverseComplement(in1$PP145891.1_Lumpy_skin_disease_virus_MVZT2331_Bera_2021_Sep_2021_Bovine_KK_Cross [[1]])
  str(m4)
m7 <- microseq::reverseComplement(in1$OM373209.1_Lumpy_skin_disease_virus_LSDV_BH3_CHN_20_2020_bovine [[1]])
  str(m5)
  

in1$OK422492.1_Lumpy_skin_disease_virus_LSDV_Cattle_India_2019_Ranchi_1_P10_31_Dec_2019_Bos_indicus [[1]] <- m3
str(in1$OK422492.1_Lumpy_skin_disease_virus_LSDV_Cattle_India_2019_Ranchi_1_P10_31_Dec_2019_Bos_indicus [[1]])

in1$OK422493.1_Lumpy_skin_disease_virus_LSDV_Cattle_India_2019_Ranchi_1_P30_31_Dec_2019_Bos_indicus [[1]] <- m4
str(in1$OK422493.1_Lumpy_skin_disease_virus_LSDV_Cattle_India_2019_Ranchi_1_P30_31_Dec_2019_Bos_indicus [[1]])

in1$ON400507.1_Lumpy_skin_disease_virus_208_PVNRTVU_2020_2020_cattle [[1]] <- m5
str(in1$ON400507.1_Lumpy_skin_disease_virus_208_PVNRTVU_2020_2020_cattle [[1]])

in1$PP145891.1_Lumpy_skin_disease_virus_MVZT2331_Bera_2021_Sep_2021_Bovine_KK_Cross [[1]] <- m6
str (in1$PP145891.1_Lumpy_skin_disease_virus_MVZT2331_Bera_2021_Sep_2021_Bovine_KK_Cross [[1]])

in1$OM373209.1_Lumpy_skin_disease_virus_LSDV_BH3_CHN_20_2020_bovine [[1]] <- m7 
str(in1$OM373209.1_Lumpy_skin_disease_virus_LSDV_BH3_CHN_20_2020_bovine [[1]])

# The above replace the original seq with the reverse complemented one



median1 <- median(summary(lengths(str_split(in1, ""))))
sd1 <- sd(summary(lengths(str_split(in1, ""))))

print(length(lengths(in1)))
print(paste("range:", round(median1+sd1+sd1), "to",
            round(median1-sd1-sd1 )))
counter=0
for (i in 1:length(lengths(str_split(in1, "")))){ 
  if(( lengths(str_split(in1[i], "")) > median1+3*sd1)||
     ( lengths(str_split(in1[i], "")) < median1-3*sd1)){
    print(lengths(str_split(in1[i], "")))
    print(i)
    counter = counter+1
    in1 <- in1[-i]}  }
print(length(lengths(in1)))
print(paste("Removed", counter, "seqs"))

old_fasta2 <- gsub("_", "_2_", old_fasta) 
names(in1) <- gsub("_NA_NA", "", names(in1)) 
names(in1) <- gsub("__", "_", names(in1)) 
names(in1) <- gsub("LSD", "_", names(in1)) 


###########################
## Genome Length of CPPV ##
###########################

#pre-length
GL1 <- nchar(in1, type = "chars", allowNA = FALSE, keepNA = NA)
view(GL1)

hist(GL1, breaks = 25)


##################################################################
## Excluding CPPV sequences with genome length less than 147 kb ##
##################################################################

# This is to exclude some sequences from our database
# rerun this two times
#in2 <- in1 #if we want to keep both pre and post-length files

counter2=0 # set up counter
for (i in 1:length(lengths(str_split(in1, "")))){ # start for loop
  if(( lengths(str_split(in1[i], "")) > 180000)||   # if either too long
     ( lengths(str_split(in1[i], "")) < 147000)){   # or too small
    print(lengths(str_split(in1[i], "")))   # print the length
    print(i)                                     # print the sample name
    print(lengths(str_split(in1[i], "")))
    counter2 = counter2+1  # increment counter
    in1 <- in1[-i]   } # end if statement 
 }  # end for loop

#NOTES
# This first [1] creates and empty counter called "counter2" that we use to count through our sequences to see how many we exclude. 
# Then next [2] it creates a for loop to loop through each of the sequences from 1 ... to the final one ( denoted length(lengths(str_split(in1, ""))) ). 
# [3] Each of the samples's length is "lengths(str_split(in1[i], ""))" where [i] is the for loop counter, so the if conditional statement if asking: is this sequence larger than 180 Kb (which is too big) or smaller than 147 Kb. 
# [4] If either one is TRUE, then we reassign in1 as in1[-i] where the -i means to remove that short/long sequence - this happens in the final line at "in1 <- in1[-i]". Then [5] we close the if statement with } and close the for loop with }.

# Check the length 
# post-length
GL2 <- nchar(in1, type = "chars", allowNA = FALSE, keepNA = NA)
view(GL2)


################################
## Histogram of Genome Length ##
################################

# Create two example datasets

xmin <- min(GL1)
xmax <- max(GL1)

# Create the first histogram
hist(GL1, main = "", xlab = "Genome Length (base pair)", ylab = "Frequency",
     col = "#298c8c", xlim = c(138000, xmax), breaks=99)
# Create the second histogram
hist(GL2, main = "Histogram 2", xlab = "Value", ylab = "Frequency",
     col = "#800074", add = TRUE, xlim = c(xmin, xmax))
grid()


# Write sequence(s) into a file in fasta format using write.fasta {seqinr}

write.fasta(in1 , names(in1), file.out = "CPPV.length.fasta", nbchar = 60)
str("CPPV.length.fasta")


##########################################
## Deleting new sequences from analysis ##
##########################################

# Load necessary libraries
#if (!requireNamespace("BiocManager", quietly = TRUE)) {
    #install.packages("BiocManager")}

#BiocManager::install("Biostrings")
#library(Biostrings)

# Read the FASTA file
# Replace "input.fasta" with the path to FASTA file
fasta_file <- "CPPV.length.fasta"
sequences <- readDNAStringSet(fasta_file)

# List of sequence names to delete (without the '>')
sequences_to_delete <- c("PP756497.1_Lumpy_skin_disease_virus_Bangladesh___Vaccine_2021_Cattle", "PP746705.1_Lumpy_skin_disease_virus_Bangladesh___29_2021_cattle", 
                          "OR797612.1_MAG_Lumpy_skin_disease_virus__V_CHINA_Tibet_2023_2023_bovine")


# Filter the sequences
#Filter the sequences to remove the specified ones:
filtered_sequences <- sequences[!(names(sequences) %in% sequences_to_delete)]

# Write the filtered sequences to a new FASTA file
# Replace "filtered_output.fasta" with the desired output file name
output_file <- "CPPV.length.filtered.fasta"
writeXStringSet(filtered_sequences, filepath = output_file)

# Optional: Print the names of the remaining sequences
print(names(filtered_sequences))


#read fasta
in1 <- seqinr::read.fasta(output_file, seqtype = c("DNA"), as.string = T)
typeof(in1[1])
str(in1)       

# read.fasta(old_fasta, seqtype = c("DNA"), as.string = T)


#############################
## Library Quality Control ##
#############################

# str(strsplit(in1[[k]], ""))

## mask 5' and 3' end 

for (k in 1:length(lengths(in1))){
  xx <- as.data.frame(strsplit(in1[[k]], ""))
  colnames(xx) <- "A"
  #str(xx)
  for (j in 1:1000){ xx$A[j] <- "n" }
  for (j in (dim(xx)[1]-1000):dim(xx)[1]){ xx$A[j] <- "n" }
  str(xx)
  #str(paste(xx$A, collapse=""))
  in1[[k]] <- paste(xx$A, collapse="") } # end for

write.fasta(in1, names(in1), file.out = "CPPV.length.filtered.QC.fasta")
typeof("CPPV.length.filtered.QC.fasta"[1])
str("CPPV.length.filtered.QC.fasta")  


###################################
## Sequence Alignment with MAFFT ##
###################################

mafft --thread 50 --auto CPPV.length.filtered.QC.fasta  > CPPV.length.filtered.QC.aln

###################################
## Substitution Model Comparison ##
###################################

# Copy modeltest-gui from my folder to your folder:
cp /mnt/lustre/RDS-live/downing/modeltest-gui  . 

# Copy seqs.fasta from my folder to your folder:
cp /mnt/lustre/RDS-live/downing/PHYLOGEN/seqs.fas  . 

# Run it with a . and / in front to make it executable:
./modeltest-gui
# Note this is a GUI tool, so an X11 window will appear

# Load the above DNA sequence alignment at "Load MSA"

# Go to the Settings Tab and set up the alignment

# parameters/settings: Maximum Likelihood

# Hit "Run" and examine the results
     # The substitution model selected is based on Bayesian Information Criterion (BIC)


####################################
## Phylogenetic Tree Construction ##
####################################


# # /mnt/lustre/RDS-live/downing/miniconda3/bin/raxml-ng --all --msa CPPV.length.filtered.QC.aln --model TVM+G4 --prefix CPPV --seed 2 --bs-metric fbp,tbe  

# add --redo to overwrite the results

# tree from RAxML after Mafft alignment
tree <- read.tree("CPPV.raxml.supportTBE")

tree$node.label <- round(100*as.numeric(tree$node.label),0)
hh <- ggtree(midpoint.root(ladderize(tree)), size=0.5) +   geom_tiplab(hjust=0, size=1)+   geom_treescale(offset=0.35, fontsize =4) + geom_tippoint(size=1)  
pdf("CPPV.length.filtered.QC.pdf", width=27, height=15)
hh + coord_cartesian(clip='off') + theme_tree2(plot.margin=margin(6,110,6,6))
dev.off()



### end 
